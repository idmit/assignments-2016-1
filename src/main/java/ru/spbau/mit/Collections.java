package ru.spbau.mit;

import java.util.ArrayList;
import java.util.Iterator;

public final class Collections {
    private Collections() {
    }

    public static <T, R> Iterable<R> map(Function1<? super T, ? extends R> fun, Iterable<T> data) {
        ArrayList<R> transformedData = new ArrayList<>(0);
        Iterator<T> itr = data.iterator();

        while (itr.hasNext()) {
            transformedData.add(fun.apply(itr.next()));
        }

        return transformedData;
    }

    // Extra type-parameter allows saving to a variable of
    // wider type in terms of elements.
    public static <T extends R, R> Iterable<R> filter(Predicate<? super T> p, Iterable<T> data) {
        ArrayList<R> filteredData = new ArrayList<>(0);
        Iterator<T> itr = data.iterator();

        while (itr.hasNext()) {
            T e = itr.next();
            if (p.apply(e)) {
                filteredData.add(e);
            }
        }

        return filteredData;
    }

    // Extra type-parameter allows saving to a variable of
    // wider type in terms of elements.
    public static <T extends R, R> Iterable<R> takeWhile(Predicate<? super T> p, Iterable<T> data) {
        ArrayList<R> shortenedData = new ArrayList<>(0);
        Iterator<T> itr = data.iterator();

        // Somehow can't be covered by tests because of generated byte code.
        while (itr.hasNext()) {
            T e = itr.next();
            if (!p.apply(e)) {
                break;
            }
            shortenedData.add(e);
        }

        return shortenedData;
    }

    // Extra type-parameter allows saving to a variable of
    // wider type in terms of elements.
    public static <T extends R, R> Iterable<R> takeUnless(Predicate<? super T> p, Iterable<T> data) {
        return takeWhile(p.not(), data);
    }

    // Extra type-parameter allows saving to a variable of
    // wider type in terms of result.
    public static <A extends R, T, R> R foldl(Function2<? super A, ? super T, ? extends A> fun,
                                              A z, Iterable<T> data) {
        Iterator<T> itr = data.iterator();

        while (itr.hasNext()) {
            z = fun.apply(z, itr.next());
        }

        return z;
    }

    // Extra type-parameter allows saving to a variable of
    // wider type in terms of result.
    public static <A extends R, T, R> R foldr(Function2<? super T, ? super A, ? extends A> fun,
                                              A z, Iterable<T> data) {
        ArrayList<T> elements = new ArrayList<>(0);
        Iterator<T> itr = data.iterator();

        while (itr.hasNext()) {
            elements.add(itr.next());
        }

        for (int k = elements.size() - 1; k >= 0; k--) {
            z = fun.apply(elements.get(k), z);
        }

        return z;
    }
}
